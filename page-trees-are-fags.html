<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet" />
    <link href="treestyle.css" rel="stylesheet" />
	<script type="text/javascript" src="js/jquery-3.3.1.js"></script>
	<script type="text/javascript" src="js/swipe.min.js"></script>
	<script type="text/javascript">

		let playButton;
		let swipe;

		let cues;
		let player;
		let timeline;

		const undynamicFullNarration = 'main-narration'
		const dynamicNarration = 'trees-are-fags-v2'

		$(document).ready(init);

		function init() {
		    // setup jQuery refs
			playButton = $('#playpause');

            // setup player
            const cuePoolTotal = 10; // total number of phrases in the pool
            cues = new Cues(cuePoolTotal);
            // DEFINE CUE POSITIONS HERE
            const playlist = [261.26, 356.18, 430.94, 529.53, 647.82, 746.13, 888.74, 1022.92];
            const startTime = 200;
            const skipTime = 5; // seconds to skip forward/back using buttons

            player = new Player(startTime, playlist, skipTime);
            playButton.click( () => { player.playPause(); });
            $('#rew').click( () => { player.rew(); });
            $('#ffw').click( () => { player.ffw(); });

            // initialise timeline
            const tlSettings = {
                dimensions  : [601, 250],
                pad         : 10,
                offsetY     : 100,
                segInterval : 0.01,
                lineWeight  : 3
            };
            timeline = new Timeline(tlSettings);
            // setup swipe
			swipe = new Swipe($('#slider')[0], {
				speed: 700, // of transition (ms)
				continuous: false, // ie. don't cycle back round
				disableScroll: true,
                draggable: true, // swipe on desktop
			});
			swipe.setup();

            // setup left and right keys (for closure)
            const Key = {
                LEFT: 37,
                RIGHT: 39
            };
            // arrow keys to move between swipe pages
			window.addEventListener('keydown', function(e) {
				if (!e) e = window.event;
				// setup keys
				const keycode = e.keyCode || e.which;
				// test keys
				if (keycode === Key.LEFT) {
					swipe.prev();
				} else if (keycode === Key.RIGHT) {
				    if (swipe.getPos() === 0) player.preload();
					swipe.next();
				}
			});
			// report seek time
            window.setInterval( () => {
                console.log("Play position: " + player.narration.currentTime);
            }, 10000);
			// report seek time
            window.setInterval( () => {
                console.log("Play position: " + player.narration.currentTime);
            }, 10000);
		}

		// object manages pool of shuffled cues (as filenames only)
		function Cues(total) {
			console.log("Cues created");

			this.fileList = [];
			this.total = total;
			this.used = 0; // how many cues have been given away

			// initialise filenames array
			for (let i = 0; i < this.total; ++i) {
				this.fileList[i] = getFileName(i+1);
			}
			// shuffle
			this.fileList = shuffleArray(this.fileList);

			// get next filename from array
			this.getNextCue = function() {
				if (this.used < this.total) {
					return this.fileList[this.used++];
				}
			};
		}

		function Cue(start) {
			this.start = start; // start time in main narration timeline
			this.active = false;
			this.hasLoaded = false;

			const file = cues.getNextCue();
			console.log("Creating Cue on file = " + file);
			this.audio = new Audio(file);
			this.audio.preload = 'auto';

            this.audio.addEventListener('ended', () => { this.ended(); });
			this.audio.addEventListener('canplaythrough', () => { this.loaded(); });
		}

		Cue.prototype =
        {
            loaded: function() {
                console.log('Cue loaded');
                this.hasLoaded = true;
                if (player.waitLoad) {
                    player.audioUnwaiting();
                }
            },

            preload: function() {
                this.audio.play();
                this.audio.pause();
                // calculate end time in main timeline
                this.end = this.start + this.audio.duration;
                console.log("Cue start: " + this.start + " Cue end: " + this.end);
            },

			play: function() {
			    if (!this.hasLoaded) {
			        player.audioWaiting();
                } else if (this.audio) {
					this.audio.play();
				}
			},

			pause: function() {
				this.audio.pause();
			},

			go: function() {
				this.active = true;
				this.play();
				const myCueNumber = player.curCue();
				console.log('Cue ' + myCueNumber + ' triggered');
			},

            // played through (onEnded)
			ended: function() {
                console.log('Cue ended');
                this.audio.pause();
				this.active = false;
				player.nextCue();
			},

			deactivate: function() {
                console.log('Cue deactivated');
				if (this.active) {
					this.active = false;
                    this.audio.pause();
					this.audio.currentTime = 0;
				}
			}

		};

		// main Player object
		function Player(startTime, playlist, skipTime) {

			this.skipTime = skipTime;
			this.playing = false;
            this.preloaded = false;
			this.waitForCue = false;
			this.waitLoad = false;
            this.skipTime = skipTime;
            this.startTime = startTime;

			// initialise main narration audio
			this.narration = new Audio(getFileName(dynamicNarration));
			this.narration.preload = "auto";
            this.narration.addEventListener('canplaythrough',  () => { this.loaded(); });
			this.narration.addEventListener('timeupdate',  () => { this.seek(); });
			this.narration.addEventListener('ended',  () => { this.ended(); });
			this.narration.addEventListener('waiting',  () => { this.audioWaiting(); });
			this.narration.addEventListener('playing',  () => { this.audioUnwaiting(); });
            this.narration.addEventListener('canplaythrough',  () => { this.loaded(); });
			this.narration.addEventListener('timeupdate',  () => { this.seek(); });
			this.narration.addEventListener('ended',  () => { this.ended(); });
			this.narration.addEventListener('waiting',  () => { this.audioWaiting(); });
			this.narration.addEventListener('playing',  () => { this.audioUnwaiting(); });

            // initialise cues
            this.cues = [];
            this.currentCueNumber = -1; // index of next/current cue (will be incremented on first call of nextCue)
            const listlen = playlist.length;
            console.log("listlen = " + listlen);
            for (let i = 0; i < listlen; i++) {
                const newCue = new Cue(playlist[i]);
                this.cues.push(newCue);
                console.table(this.cues[i]);
            }
            this.nextCue();
		}

		Player.prototype =
        {
			// get currently queued cue (or null)
			curCue: function() {
				if (this.currentCueNumber >= this.cues.length) {
					return null;
				}
				return this.cues[this.currentCueNumber];
			},

			// get currently active cue (or null)
			activeCue: function() {
				const cue = this.curCue();
				if (cue && cue.active) {
					return cue;
				} else {
					return null;
				}
			},

			play: function() {
                this.playing = true;
				if (!this.waitForCue) this.narration.play();
				const cue = this.activeCue();
				if (cue) cue.play();
				playButton.addClass('pause');
			},

			pause: function() {
				this.playing = false;
				if (!this.waitForCue) this.narration.pause();
				const cue = this.activeCue();
				if (cue) cue.pause();
				playButton.removeClass('pause');
			},

			// method called directly by pressing the play/pause button
			playPause: function() {
			    if (!this.waitLoad) {
                    if (this.playing) {
                        this.pause();
                    } else {
                        this.play();
                    }
                }
			},

            // skip forwards/backwards [amount] secs
			skip: function(amount) {
				let newNarrationTime = this.narration.currentTime + amount;
				// skip in current active cue
				let cue = this.curCue();
				if (cue) {
					if (cue.active) {
					    // are we stepping out of the time bounds of currently playing cue?
						if (newNarrationTime < cue.start) {
							cue.deactivate();
						} else if (newNarrationTime > cue.end) {
							cue.ended();
						} else {
							cue.audio.currentTime = newNarrationTime - cue.start;
						}
					} else if (newNarrationTime > cue.start) {
					    // should a cue be triggered now?
						cue.go();
						cue.audio.currentTime = newNarrationTime - cue.start;
					}
				}
				// are we skipping back into a previous cue?
				if (this.currentCueNumber > 0 && newNarrationTime < this.cues[this.currentCueNumber-1].end) {
					this.currentCueNumber--;
					cue = this.curCue();
					cue.go();
					cue.audio.currentTime = newNarrationTime - cue.start;
				}
				// skip in narration
				if (newNarrationTime > this.narration.duration) {
					this.ended();
				} else if (newNarrationTime < 0) {
				    this.narration.currentTime = 0;
                } else {
                    this.narration.currentTime = newNarrationTime;
                }
				console.log("Skipped to: " + this.narration.currentTime);
			},

			rew: function() {
			    if (!this.waitLoad) {
			        console.log('REwinding');
                    this.skip(-this.skipTime);
                }
			},

			ffw: function() {
			    if (!this.waitLoad) {
                    console.log('FFWing');
                    this.skip(this.skipTime);
                }
			},

			seek: function() {
				const cue = this.curCue();
				if (cue && !cue.active && this.narration.currentTime >= cue.start) { // test we haven't run out of cues yet
					cue.go();
				}
                timeline.draw(this.narration.currentTime / this.narration.duration);
			},

            nextCue: function() {
			    this.currentCueNumber++;
                const cue = this.curCue();
                if (cue) {
                    // cue.setup();
                }
            },

            // finished playing through
            ended: function() {
                this.pause();
                const cue = this.activeCue();
                if (cue) cue.deactivate();
                this.waitForCue = false;
                this.currentCueNumber = 0;
                this.narration.currentTime = 0;
                swipe.slide(2, 600); // go to credits page
            },

            // play and pause each audio asset to trigger preloading on iOS
            // (needs to be in an on-click event)
            preload: function() {
			    if (!this.preloaded) {
			        this.preloaded = true;
                    this.narration.currentTime = this.startTime;
                    this.narration.play();
                    window.setTimeout( () => { this.narration.pause(); }, 5);
                    const cueLen = this.cues.length;
                    for (let i = 0; i < cueLen; i++) {
                        this.cues[i].preload();
                    }
                }
            },

            // for canplaythrough event
            loaded: function() {
			    console.log('loaded');
			    if (this.waitLoad) {
			        this.audioUnwaiting();
                }
            },

            // if any element that needs to play now hasn't loaded (or onWaiting events)
            audioWaiting: function() {
                if (!this.waitLoad) {
                    this.waitLoad = true;
                    playButton.addClass('loading');
                }
            },

            // onPlaying - once an element that needs to play now has loaded
            audioUnwaiting: function() {
                if (this.waitLoad) {
                    this.waitLoad = false;
                    playButton.removeClass('loading');
                }
            },
		};

		function Timeline(settings)
        {
            this.pad = settings.pad;
            this.offsetY = settings.offsetY;
            this.segInterval = settings.segInterval;
            this.lastValue = 0;
            this.dim = settings.dimensions;

            this.start = [this.pad, this.dim[1] - this.pad];
            this.end = [this.dim[0] - this.pad, this.start[1] - this.offsetY];
            this.range = this.end[1] - this.pad;

            // setup first line segment
            this.segs = [];
            let firstPoint = this.start;
            firstPoint.push(0); // 2th index is time value
            const secondPoint = this.pickPoint(this.segInterval);
            const firstSeg = [firstPoint, secondPoint];
            this.segs.push(firstSeg);

            // and finally, our canvas
            this.canvas = $('#timeline')[0].getContext('2d');
            this.canvas.lineCap = 'round';
            this.canvas.lineWidth = settings.lineWeight;
            this.canvas.strokeStyle = 'rgba(255,255,255,0.9)';
        }

        Timeline.prototype =
        {
            interp: function(pointFrom, pointTo, value) {
                const vector = [pointTo[0] - pointFrom[0], pointTo[1] - pointFrom[1]];
                const x = pointFrom[0] + value * vector[0];
                const y = pointFrom[1] + value * vector[1];
                const result = [x, y, value];
                return result;
            },

            // interpolate for whole timeline
            valueToPoint: function(value) {
                return this.interp(this.start, this.end, value);
            },

            // pick a new point at [value] along the line, with Y wiggle
            pickPoint: function(value) {
                let point = this.valueToPoint(value); // choose a point along the baseline
                point[1] -= Math.random()*this.range; // add a random Y offset
                return point;
            },

            // commence a new segment of the line
            newSeg: function() {
                const lastSeg = this.segs.length - 1;
                const joint = this.segs[lastSeg][1]; // make end of last seg start of new one
                const newValue = this.segs[lastSeg][1][2] + this.segInterval;
                const segEnd = this.pickPoint(newValue);
                this.segs.push([joint, segEnd]);
            },

            // commence a new segment, broken off from the previous one
            newBranch: function() {
                this.newSeg();
                const lastSeg = this.segs.length-1;
                this.segs[lastSeg][0] = this.pickPoint(this.segs[lastSeg][0][2]);
            },

            draw: function(value) {
                let lastSeg = this.segs.length - 1;
                // add new segments to reach value
                while (value > this.segs[lastSeg][1][2]) {
                    this.newSeg();
                    lastSeg ++;
                }
                // get first segment that needs redrawn
                for (let i = lastSeg - 1; i >= 0 && this.lastValue < this.segs[i][1][2]; i--)
                    ;
                i = i < 0 ? 0 : i;
                // clear canvas from segs[lastSeg][0][0] to segs[lastSeg][1][0]
                this.canvas.clearRect(this.segs[i][0][0], 0, this.dim[0], this.dim[1]);
                // fill in all previously unrendered whole segments
                for (; i < lastSeg && value < this.segs[i][1][2]; i ++) {
                    this.canvas.moveTo(this.segs[i][0][0], this.segs[i][0][1]);
                    this.canvas.lineTo(this.segs[i][1][0], this.segs[i][1][1]);
                    this.canvas.stroke();
                }
                // remove spare segments
                while (i < this.segs.length - 1) this.segs.pop();
                // draw current segment
                const relativeValue = (value-this.segs[i][0][2]) / (this.segs[i][1][2] - this.segs[i][0][2]);
                const endPoint = this.interp(this.segs[i][0], this.segs[i][1], relativeValue);
                this.canvas.moveTo(this.segs[i][0][0], this.segs[i][0][1]);
                this.canvas.lineTo(endPoint[0], endPoint[1]);
                this.canvas.stroke();
                this.lastValue = value;
            }
        };

		// for 'continue' button - swipe to next page and preload
		function nextAndLoad() {
			player.preload(); // trigger preloading on iOS
			swipe.next();
		}

		function getFileName(affix) {
			const dir = "audio/"; // directory/URI
			const prefix = "cue-"; // prefix if cue (ie. if passed a number)
			const postfix = ".mp3"; // format
			if (typeof affix === 'number') { // if passed a number, it's a cue
				if (affix < 10) affix = '0' + affix; // 0-padding
				return dir + prefix + affix + postfix;
			} else { // if passed text, that's the name of the main narration file
				return dir + affix + postfix;
			}
		}

		// based on Knuth Shuffle (https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array)
		function shuffleArray(arr) {
			let currentIndex = arr.length;
			let randomIndex, temp;

			// While there remain elements to shuffle...
			while (currentIndex !== 0) {
				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex--;
				// Swap with current
				temp = arr[randomIndex];
				arr[randomIndex] = arr[currentIndex];
				arr[currentIndex] = temp;
			}
			return arr;
		}

		function consoleLog(text) {
			$('#console').append('<p>' + text + '</p>');
			console.log(text);
		}

		// function loadLoop() {
		// 	var buffered = intro.buffered;
		// 	var dur = intro.duration;
		// 	var loaded;
		// 	if (buffered.length) {
		// 		loaded = 100 * buffered.end(0) / dur;
		// 		loadBar.html(loaded + '%');
		// 	}
		// 	if (buffered.length < dur) {
		// 		setTimeout(loadLoop, 200);
		// 	}
		// }

	</script>
</head>
<body>
<!-- <div id="console"></div> -->
<img src="imgs/title-large.png" class="title" alt="Trees Are Fags" />
<div class="timeline"><canvas id="timeline" width="600" height="250"></canvas></div>
<div id="slider" class="swipe">
    <div class="swipe-wrap">
        <!-- ................page 1...........-->
        <div class="page">
            <div class="text-body">
                <p>
                    This is a guided encounter with a tree, so it is best that you listen in the company of trees. You will be led through a series of observations, reflections and movements in relation to trees. The encounter lasts just over 20 minutes. So find a spot among trees, turn off the ringer of your device, and when you are ready, swipe to the next screen to begin <em>Trees Are Fags</em>.
                </p>
                <p align="right">
                    <a onclick="nextAndLoad()" href="#">Click here to continue &gt;</a>
                </p>
            </div>
        </div>
        <!-- ................page 2...........-->
        <div class="page">
            <div class="controls">
                <div class="controlButton" id="rew"></div>
                <div class="controlButton play loading" id="playpause"></div>
                <div class="controlButton" id="ffw"></div>
            </div>
        </div>
        <!-- ................page 3...........-->
        <div class="page">
            <div class="text-body">
                <p>
                    <em>Trees are Fags</em> is an encounter created in 2018 by Benny Nemerofsky Ramsay, programmed and sound designed by Nikita Gaidakov. The piece features the voices of Matt Carter, Oskar Kirk Hansen, Bastien Pourtout, Edward Twaddle, Alberta Whittle and Virginia Woolf. Fragments from Sofia Gubaidulinaâ€™s <em>Sonata for Two Bassoons</em> (1977) was performed by Ronan Whittern. <em>Trees are Fags</em> was commissioned by Lux and co-produced by the <em>Cruising the Seventies</em> research team at the Edinburgh College of Art. For more information on Benny Nemerofsky Ramsay, visit <a href="http://www.nemerofsky.ca">www.nemerofsky.ca</a>.
                </p>
                <p align="center"><img src="imgs/logos.png" width="150" /></p>
            </div>
        </div>
    </div>
</div>
</body>
</html>
